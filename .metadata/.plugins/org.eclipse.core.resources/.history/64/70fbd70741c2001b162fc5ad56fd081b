/*
 * generated by Xtext 2.25.0
 */
package org.xtext.uma.usex.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.uma.usex.usex.Model
import org.xtext.uma.usex.usex.UseClass
import org.xtext.uma.usex.usex.Operation
import org.xtext.uma.usex.usex.Method
import org.xtext.uma.usex.usex.Query
import org.xtext.uma.usex.usex.Attribute
import org.xtext.uma.usex.usex.AttributeType
import org.xtext.uma.usex.usex.ClassType
import org.xtext.uma.usex.usex.PrimitiveType
import org.xtext.uma.usex.usex.StringInitialization
import org.xtext.uma.usex.usex.IntegerInitialization
import org.xtext.uma.usex.usex.BooleanInitialization
import org.xtext.uma.usex.usex.DoubleInitialization
import org.xtext.uma.usex.usex.AttributeInitialization
import org.eclipse.emf.common.util.EList
import org.xtext.uma.usex.usex.Parameter
import org.xtext.uma.usex.usex.Condition
import org.xtext.uma.usex.usex.Precondition
import org.xtext.uma.usex.usex.Postcondition
import org.xtext.uma.usex.usex.Constraint
import org.xtext.uma.usex.usex.ConditionBody
import org.xtext.uma.usex.usex.Association
import org.xtext.uma.usex.usex.Composition
import org.xtext.uma.usex.usex.RelationBody
import org.xtext.uma.usex.usex.RelationMember
import org.xtext.uma.usex.usex.CardinalityType
import org.xtext.uma.usex.usex.SimpleCardinality
import org.xtext.uma.usex.usex.DoubleCardinality
import org.xtext.uma.usex.usex.CardinalityValue
import org.xtext.uma.usex.usex.IntCardinality
import org.xtext.uma.usex.usex.AsteriskCardinality
import org.xtext.uma.usex.usex.Relation

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
 
class UsexGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.allContents.toIterable.filter(Model).get(0);
		// Additions to the model
		
		
		// Generate processed model
		fsa.generateFile(model.name+".use", model.compile);
	}
	
	def getMethods(Model m) {
		return 
	}
	
	// Model compilation
	def compile(Model m) 
	'''
	model «m.name»
	
	««« Classes
	«FOR useClass : m.elements.filter(UseClass)»
		«useClass.compile»
	«ENDFOR»

	««« Relations
	«FOR relation : m.elements.filter(Relation)»
		gooo
		«relation.compile»
	«ENDFOR»
	'''
	
	// Class compilation
	def compile(UseClass cl) 
	'''
		class «cl.name»:
		«IF !cl.attributes.isEmpty»	attributes
			«FOR attribute : cl.attributes»
				«attribute.compile»
			«ENDFOR»
		
		«ENDIF»
		«IF !cl.operations.isEmpty»operations
			«FOR operation : cl.operations»
				«operation.compile»
			«ENDFOR»
		
		«ENDIF»
		«IF !cl.constraints.isEmpty»constraints
			«FOR constraint : cl.constraints»
				«constraint.compile»
			«ENDFOR»
		«ENDIF»
		end
		
	'''
	
	// Operation compilation
	def compile(Operation op) 
	{
		switch(op) {
			Method:
				(op as Method).compile
			Query:
				(op as Query).compile
		}
	}
	
	// Attribute compilation
	def compile(Attribute attr) 
	'''
			«attr.name» : «attr.type.compile»
				«IF attr.initialization !== null»
					init «attr.initialization.compile»
				«ENDIF»
				«IF attr.derivedFrom !== null»
					derived: «attr.derivedFrom»
				«ENDIF»
	'''
	
	// AttributeType compilation
	def compile(AttributeType attrType) 
	{
		switch(attrType) {
			ClassType: 
				(attrType as ClassType).type.name
			PrimitiveType:
				(attrType as PrimitiveType).type
		}
	}
	
	// AttributeInitialization compilation
	def compile(AttributeInitialization attrInit) {
		switch(attrInit) {
			DoubleInitialization:
				(attrInit as DoubleInitialization).value
			BooleanInitialization:
				(attrInit as BooleanInitialization).value
			IntegerInitialization:
				(attrInit as IntegerInitialization).value
			StringInitialization:
				(attrInit as StringInitialization).value
		}
	}
	
	// Method compilation
	def compile(Method m) 
	'''
		«m.name»(«listParameters(m.inputParameters)») «m.writeReturn»
		«IF m.operationBody !== null»
		begin
			«m.operationBody»
		end
		«ENDIF»
		«IF m.conditions !== null»«FOR cond : m.conditions»«cond.compile»«ENDFOR»«ENDIF»
		
	'''
	
	// Query compilation
	def compile(Query q)
	'''
		«q.name»(«listParameters(q.inputParameters)») «q.writeReturn»
			= «q.operationBody»
		
	'''
	
	def writeReturn(Operation op) {
		var sB = new StringBuilder()
		var oper = op instanceof Method ? op as Method : op as Query
		
		if(oper.returnParameter !== null) {
			sB.append(": " + oper.returnParameter.compile)
		}
		
		return sB.toString
	}
	
	def listParameters(EList<Parameter> lP) 
	{
		var sB = new StringBuilder();
		
		for (param : lP) {
			sB.append(param.compile+',')
		}
		if (sB.length > 0) {
			sB = new StringBuilder(sB.substring(0, sB.length-1))
		}
		
		return sB.toString
	}
	
	// Parameter compilation
	def compile(Parameter p) 
	'''
		«p.name» : «p.type.compile»'''
	
	
	// Condition compilation
	def compile(Condition c) 
	{
		switch(c) {
			Precondition:
				(c as Precondition).compile
			Postcondition:
				(c as Postcondition).compile
		}
	}
	
	def compile(Constraint c) 
	'''
		inv «c.conditionBody.compile»
	'''
	
	def compile(Precondition p) 
	'''
		pre «p.conditionBody.compile»
	'''
	
	def compile(Postcondition p) 
	'''
		post «p.conditionBody.compile»
	'''
	
	// ConditionBody compilation
	def compile(ConditionBody cB) 
	'''
		«IF cB.name !== null» «cB.name»«ENDIF»:
			«cB.condition»
	'''

	// Relation compilation
	def compile(Relation r) {
		switch(r) {
			Association:
				'''
				association «r.name» between
				«r.relationBody.compile»
				end
				'''
			Composition:
				'''
				composition «r.name» between
				«r.relationBody.compile»
				end
				'''
		}
	}

	// RelationBody compilation
	def compile(RelationBody rB)
	'''
		«rB.originClass.compile»
		«rB.destinyClass.compile»
	'''

	// RelationMember compilation
	def compile(RelationMember rM)
	'''
		«rM.class_.compile» [«rM.cardinality.compile»] role «rM.roleName»
	'''
	
	// CardinalityType compilation
	def compile(CardinalityType cT) {
		switch(cT) {
			case SimpleCardinality:
				'''«(cT as SimpleCardinality).cardinality.compile»'''
			case DoubleCardinality:
				'''«(cT as DoubleCardinality).compile»'''
		}
	}
	
	// DoubleCardinality compilation
	def compile(DoubleCardinality cT)
	'''
		«(cT as DoubleCardinality).originCardinality.compile»..«(cT as DoubleCardinality).destinyCardinality.compile»
	'''
	
	// CardinalityValue compilation
	def compile(CardinalityValue cV) 
	{
		switch(cV) {
			case IntCardinality:
				return (cV as IntCardinality).value.toString
			case AsteriskCardinality:
				return '*'
		}
	}
	
}
