/*
 * generated by Xtext 2.25.0
 */
package org.xtext.uma.usex.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.uma.usex.usex.Model
import org.xtext.uma.usex.usex.UseClass
import org.xtext.uma.usex.usex.Operation
import org.xtext.uma.usex.usex.Method
import org.xtext.uma.usex.usex.Query
import org.xtext.uma.usex.usex.Attribute
import org.xtext.uma.usex.usex.AttributeType
import org.xtext.uma.usex.usex.ClassType
import org.xtext.uma.usex.usex.PrimitiveType
import org.xtext.uma.usex.usex.StringInitialization
import org.xtext.uma.usex.usex.IntegerInitialization
import org.xtext.uma.usex.usex.BooleanInitialization
import org.xtext.uma.usex.usex.DoubleInitialization
import org.xtext.uma.usex.usex.AttributeInitialization
import org.eclipse.emf.common.util.EList
import org.xtext.uma.usex.usex.Parameter
import org.xtext.uma.usex.usex.Condition
import org.xtext.uma.usex.usex.Precondition
import org.xtext.uma.usex.usex.Postcondition
import org.xtext.uma.usex.usex.Constraint
import org.xtext.uma.usex.usex.ConditionBody
import javax.management.relation.Relation
import org.xtext.uma.usex.usex.Association
import org.xtext.uma.usex.usex.Composition
import org.xtext.uma.usex.usex.RelationBody

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class UsexGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.allContents.toIterable.filter(Model).get(0);
		// Additions to the model
		
		
		// Generate processed model
		fsa.generateFile(model.name+".use", model.compile);
	}
	
	def getMethods(Model m) {
		return 
	}
	
	// Model compilation
	def compile(Model m) 
	'''
	model «m.name»

	«FOR useClass : m.elements.filter(UseClass)»
			«useClass.compile»
	«ENDFOR»
	
	«««Relaciones
	'''
	
	// Class compilation
	def compile(UseClass cl) 
	'''
		class «cl.name»:
		«IF !cl.attributes.isEmpty»	attributes
			«FOR attribute : cl.attributes»
				«attribute.compile»
			«ENDFOR»
		
		«ENDIF»
		«IF !cl.operations.isEmpty»operations
			«FOR operation : cl.operations»
				«operation.compile»
			«ENDFOR»
		
		«ENDIF»
		«IF !cl.constraints.isEmpty»constraints
			«FOR constraint : cl.constraints»
				«constraint.compile»
			«ENDFOR»
		«ENDIF»
		end
		
	'''
	
	// Operation compilation
	def compile(Operation op) 
	{
		switch(op) {
			Method:
				(op as Method).compile
			Query:
				(op as Query).compile
		}
	}
	
	// Attribute compilation
	def compile(Attribute attr) 
	'''
			«attr.name» : «attr.type.compile»
				«IF attr.initialization !== null»
					init «attr.initialization.compile»
				«ENDIF»
				«IF attr.derivedFrom !== null»
					derived: «attr.derivedFrom»
				«ENDIF»
	'''
	
	// AttributeType compilation
	def compile(AttributeType attrType) 
	{
		switch(attrType) {
			ClassType: 
				(attrType as ClassType).type.name
			PrimitiveType:
				(attrType as PrimitiveType).type
		}
	}
	
	// AttributeInitialization compilation
	def compile(AttributeInitialization attrInit) {
		switch(attrInit) {
			DoubleInitialization:
				(attrInit as DoubleInitialization).value
			BooleanInitialization:
				(attrInit as BooleanInitialization).value
			IntegerInitialization:
				(attrInit as IntegerInitialization).value
			StringInitialization:
				(attrInit as StringInitialization).value
		}
	}
	
	// Method compilation
	def compile(Method m) 
	'''
		«m.name»(«listParameters(m.inputParameters)») «m.writeReturn»
		«IF m.operationBody !== null»
		begin
			«m.operationBody»
		end
		«ENDIF»
		«IF m.conditions !== null»«FOR cond : m.conditions»«cond.compile»«ENDFOR»«ENDIF»
		
	'''
	
	// Query compilation
	def compile(Query q)
	'''
		«q.name»(«listParameters(q.inputParameters)») «q.writeReturn»
			= «q.operationBody»
		
	'''
	
	def writeReturn(Operation op) {
		var sB = new StringBuilder()
		var oper = op instanceof Method ? op as Method : op as Query
		
		if(oper.returnParameter !== null) {
			sB.append(": " + oper.returnParameter.compile)
		}
		
		return sB.toString
	}
	
	def listParameters(EList<Parameter> lP) 
	{
		var sB = new StringBuilder();
		
		for (param : lP) {
			sB.append(param.compile+',')
		}
		if (sB.length > 0) {
			sB = new StringBuilder(sB.substring(0, sB.length-1))
		}
		
		return sB.toString
	}
	
	// Parameter compilation
	def compile(Parameter p) 
	'''
		«p.name» : «p.type.compile»'''
	
	
	// Condition compilation
	def compile(Condition c) 
	{
		switch(c) {
			Precondition:
				(c as Precondition).compile
			Postcondition:
				(c as Postcondition).compile
		}
	}
	
	def compile(Constraint c) 
	'''
		inv «c.conditionBody.compile»
	'''
	
	def compile(Precondition p) 
	'''
		pre «p.conditionBody.compile»
	'''
	
	def compile(Postcondition p) 
	'''
		post «p.conditionBody.compile»
	'''
	
	// ConditionBody compilation
	def compile(ConditionBody cB) 
	'''
		«IF cB.name !== null» «cB.name»«ENDIF»:
			«cB.condition»
	'''
	
	// Relation compilation
	def compile(Relation r)
	'''
	«switch(r) {
			Association:
				'''association «r.name» between
					«r.relationBody.compile»
				end'''
			Composition:
				'''composition «r.name»'''
		}» between «»
	'''
	
	def compile(RelationBody rB) '''
		«rB.originClass»
		«rB.destinyClass»
	'''
}
